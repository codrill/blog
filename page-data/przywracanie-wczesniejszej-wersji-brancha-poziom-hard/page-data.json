{"componentChunkName":"component---src-templates-blog-post-js","path":"/przywracanie-wczesniejszej-wersji-brancha-poziom-hard","webpackCompilationHash":"ec8539f14799761d9317","result":{"data":{"markdownRemark":{"html":"<p>Dzisiaj weźmiemy na tapetę przykład z życia i to całkiem świeży - okazało się, że na branchu\n<code>master</code> mamy nie to co powinniśmy mieć.. I to od jakiegoś czasu.  </p>\n<p>Krótka anegdotka, czyli historia o tym jak się nam posypał <code>master</code> branch:</p>\n<p>Robiliśmy mały projekcik i chcieliśmy go opublikować na github pages a proces deploymentu zautomatyzować za pomocą bibliotek\n<code>gh-pages</code>. Wszystko ładnie, pięknie, gdyby nie to, że prawie na samym początku, w konfiguracji mieliśmy omyłkowo\nustawionego deploya na branch <code>master</code>.</p>\n<p>Sprawa wyszła na jaw dopiero po kilku kolejnych commitach do <code>develop</code>a - gdy chcieliśmy zrobić kolejnego deploya.\nOczywiście nie mogliśmy dograć najnowszego <code>develop</code>a do <code>master</code>a, ponieważ <code>develop</code> powinien najpierw dociągnąć\nnajnowszą wersję z głównego brancha.. Ale tego nie chcieliśmy, bo <code>master</code> miał tylko pliki produkcyjne i nic więcej. </p>\n<p>Pojawiło się pytanie: </p>\n<p>Jak sprawić, aby branch <code>master</code> wrócił do stanu użyteczności, a przy okazji nie mieszać za bardzo w gitowej historii?</p>\n<p>Istnieje coś takiego jak <code>git revert &#x3C;commit_id></code> - jednak ta komenda sprawia, że powstaje nowy commit ze 'starymi' zmianami.\nMoże nie zawsze jest to złe rozwiązanie, jednak już kiedyś musiałem robić reverta do reverta i takie commity słabo wyglądają w historii gita.</p>\n<p>Z pomocą przychodzą dwa polecenia, ściśle ze sobą powiązane: </p>\n<p><code>git reset --hard &#x3C;commit_id></code> - spowoduje przywracenie naszego lokalny branch do stanu z commita, którego ID mu przekażemy</p>\n<p><code>git push origin &#x3C;branch_name> -f</code> - wypushuje nasze lokalne zmiany do brancha, nadpisując jednocześnie jego historie. </p>\n<p>Oczywiście polecenia wywołujemy będąc na skopanym branchu (w naszym przypadku był to <code>master</code>).</p>\n<p>Po tym zabiegu, mogliśmy już normalnie zrobić Pull Requesta, z z brancha <code>develop</code> do brancha <code>master</code>. Wszystkie zmiany były\npięknie wyświetlone, a historia brancha <code>master</code> pozostała niezbrukana.</p>\n<p>Z tego też powodu, dobrze mieć brancha <code>develop</code> - do którego mergujemy feature branche i który powinien\n(w większym lub mniejszym stopniu) także być stabilny, a nie ładować każdy nowy feature bezpośrednio do mastera. </p>\n<p>*<em>Powyższe rozwiązanie <strong>nie jest</strong> zalecane do notorycznego używania w codziennej pracy z GITem.\nPonieważ w ten sposób manipulujemy historią GITa, a nie o to chodzi w systemie kontroli wersji.\nTraktujcie je raczej jako sposób radzenia sobie z sytuacją, gdy coś nieoczekiwanie, pójdzie bardzo źle - przykładowo\nwszystkie źródła zastąpicie plikami produkcyjnymi ;)</em></p>","frontmatter":{"title":"Przywracanie wersji brancha - poziom 'hard'","date":"2019-07-16","difficulty":"średni","categories":["git","organizacja pracy"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"pathSlug":"przywracanie-wczesniejszej-wersji-brancha-poziom-hard","prev":{"frontmatter":{"path":"witaj-swiecie","title":"Witaj świecie!","categories":["pozostale"]}},"next":null}}}